!function(){"use strict";
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
class t{constructor(t,e){this.table=t,this.key=e}}
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */class e{constructor(t,e,i){this.table=t,this.cache=e,this.adapter=i}request(t){return this.adapter.newRequest("/"+t)}delete(t){return this.cache.delete(this.request(t))}keys(){return this.cache.keys().then(t=>t.map(t=>t.url.substr(1)))}read(e){return this.cache.match(this.request(e)).then(i=>void 0===i?Promise.reject(new t(this.table,e)):i.json())}write(t,e){return this.cache.put(this.request(t),this.adapter.newResponse(JSON.stringify(e)))}}
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */var i,s;!function(t){t[t.NOT_CACHED=0]="NOT_CACHED",t[t.CACHED_BUT_UNUSED=1]="CACHED_BUT_UNUSED",t[t.CACHED=2]="CACHED"}(i||(i={}));
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
class n extends Error{constructor(){super(...arguments),this.isCritical=!0}}function r(t){return t instanceof Error?`${t.message}\n${t.stack}`:`${t}`}
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */function a(t){const e=t;return o(function(t,e){const i=Array(t.length+3>>>2);for(let s=0;s<i.length;s++)i[s]=f(t,4*s,e);return i}(e,s.Big),8*e.length)}function h(t){return o(function(t,e){const i=Array(t.byteLength+3>>>2),s=new Uint8Array(t);for(let t=0;t<i.length;t++)i[t]=f(s,4*t,e);return i}(t,s.Big),8*t.byteLength)}function o(t,e){const i=new Array(80);let[s,n,r,a,h]=[1732584193,4023233417,2562383102,271733878,3285377520];t[e>>5]|=128<<24-e%32,t[15+(e+64>>9<<4)]=e;for(let e=0;e<t.length;e+=16){const[o,d,f,p,v]=[s,n,r,a,h];for(let o=0;o<80;o++){i[o]=o<16?t[e+o]:c(i[o-3]^i[o-8]^i[o-14]^i[o-16],1);const[d,f]=u(o,n,r,a),p=[c(s,5),d,h,f,i[o]].reduce(l);[h,a,r,n,s]=[a,r,c(n,30),s,p]}[s,n,r,a,h]=[l(s,o),l(n,d),l(r,f),l(a,p),l(h,v)]}return function(t){let e="";for(let i=0;i<t.length;i++){const s=d(t,i);e+=(s>>>4).toString(16)+(15&s).toString(16)}return e.toLowerCase()}
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */(function(t){return t.reduce((t,e)=>t+function(t){let e="";for(let i=0;i<4;i++)e+=String.fromCharCode(t>>>8*(3-i)&255);return e}(e),"")}([s,n,r,a,h]))}function l(t,e){return function(t,e){const i=(65535&t)+(65535&e),s=(t>>>16)+(e>>>16)+(i>>>16);return[s>>>16,s<<16|65535&i]}(t,e)[1]}function c(t,e){return t<<e|t>>>32-e}function u(t,e,i,s){return t<20?[e&i|~e&s,1518500249]:t<40?[e^i^s,1859775393]:t<60?[e&i|e&s|i&s,2400959708]:[e^i^s,3395469782]}function d(t,e){return"string"==typeof t?e>=t.length?0:255&t.charCodeAt(e):e>=t.byteLength?0:255&t[e]}function f(t,e,i){let n=0;if(i===s.Big)for(let i=0;i<4;i++)n+=d(t,e+i)<<24-8*i;else for(let i=0;i<4;i++)n+=d(t,e+i)<<8*i;return n}!function(t){t[t.Little=0]="Little",t[t.Big=1]="Big"}(s||(s={}));var p=function(t,e,i,s){return new(i||(i=Promise))(function(n,r){function a(t){try{o(s.next(t))}catch(t){r(t)}}function h(t){try{o(s.throw(t))}catch(t){r(t)}}function o(t){t.done?n(t.value):new i(function(e){e(t.value)}).then(a,h)}o((s=s.apply(t,e||[])).next())})};class v{constructor(t,e,i,s,n,r,a){this.scope=t,this.adapter=e,this.idle=i,this.config=s,this.hashes=n,this.db=r,this.prefix=a,this.inFlightRequests=new Map,this.patterns=[],this.name=s.name,this.patterns=this.config.patterns.map(t=>new RegExp(t)),this.cache=this.scope.caches.open(`${this.prefix}:${this.config.name}:cache`),this.metadata=this.db.open(`${this.prefix}:${this.config.name}:meta`),this.origin=this.adapter.parseUrl(this.scope.registration.scope,this.scope.registration.scope).origin}cacheStatus(t){return p(this,void 0,void 0,function*(){const e=yield this.cache,s=yield this.metadata;if(void 0===(yield e.match(this.adapter.newRequest(t))))return i.NOT_CACHED;try{if(!(yield s.read(t)).used)return i.CACHED_BUT_UNUSED}catch(t){}return i.CACHED})}cleanup(){return p(this,void 0,void 0,function*(){yield this.scope.caches.delete(`${this.prefix}:${this.config.name}:cache`),yield this.db.delete(`${this.prefix}:${this.config.name}:meta`)})}handleFetch(t,e){return p(this,void 0,void 0,function*(){const e=this.getConfigUrl(t.url);if(-1!==this.config.urls.indexOf(e)||this.patterns.some(t=>t.test(e))){const i=yield this.cache,s=yield i.match(t);return void 0!==s?this.hashes.has(e)?s:((yield this.needToRevalidate(t,s))&&this.idle.schedule(`revalidate(${this.prefix}, ${this.config.name}): ${t.url}`,()=>p(this,void 0,void 0,function*(){yield this.fetchAndCacheOnce(t)})),s):(yield this.fetchAndCacheOnce(this.adapter.newRequest(t.url))).clone()}return null})}getConfigUrl(t){const e=this.adapter.parseUrl(t,this.scope.registration.scope);return e.origin===this.origin?e.path:t}needToRevalidate(t,e){return p(this,void 0,void 0,function*(){if(e.headers.has("Cache-Control")){const i=e.headers.get("Cache-Control").split(",").map(t=>t.trim()).map(t=>t.split("="));i.forEach(t=>t[0]=t[0].toLowerCase());const s=i.find(t=>"max-age"===t[0]),n=s?s[1]:void 0;if(!n)return!0;try{const i=1e3*parseInt(n);let s;try{const i=yield this.metadata;s=(yield i.read(t.url)).ts}catch(t){const i=e.headers.get("Date");if(null===i)return!0;s=Date.parse(i)}const r=this.adapter.time-s;return r<0||r>i}catch(t){return!0}}else{if(!e.headers.has("Expires"))return!0;{const t=e.headers.get("Expires");try{return this.adapter.time>Date.parse(t)}catch(t){return!0}}}})}fetchFromCacheOnly(t){return p(this,void 0,void 0,function*(){const e=yield this.cache,i=yield this.metadata,s=yield e.match(this.adapter.newRequest(t));if(void 0===s)return null;let n=void 0;try{n=yield i.read(t)}catch(t){}return{response:s,metadata:n}})}unhashedResources(){return p(this,void 0,void 0,function*(){const t=yield this.cache;return(yield t.keys()).map(t=>t.url).filter(t=>!this.hashes.has(t))})}fetchAndCacheOnce(t,e=!0){return p(this,void 0,void 0,function*(){if(this.inFlightRequests.has(t.url))return this.inFlightRequests.get(t.url);const i=this.fetchFromNetwork(t);this.inFlightRequests.set(t.url,i);try{const s=yield i;if(!s.ok)throw new Error(`Response not Ok (fetchAndCacheOnce): request for ${t.url} returned response ${s.status} ${s.statusText}`);try{const i=yield this.scope.caches.open(`${this.prefix}:${this.config.name}:cache`);if(yield i.put(t,s.clone()),!this.hashes.has(t.url)){const i={ts:this.adapter.time,used:e},s=yield this.metadata;yield s.write(t.url,i)}return s}catch(e){throw new n(`Failed to update the caches for request to '${t.url}' (fetchAndCacheOnce): ${r(e)}`)}}finally{this.inFlightRequests.delete(t.url)}})}fetchFromNetwork(t,e=3){return p(this,void 0,void 0,function*(){const i=yield this.cacheBustedFetchFromNetwork(t);if(i.redirected&&i.url){if(0===e)throw new n(`Response hit redirect limit (fetchFromNetwork): request redirected too many times, next is ${i.url}`);return this.fetchFromNetwork(this.adapter.newRequest(i.url),e-1)}return i})}cacheBustedFetchFromNetwork(t){return p(this,void 0,void 0,function*(){const e=this.getConfigUrl(t.url);if(this.hashes.has(e)){const i=this.hashes.get(e),s=yield this.safeFetch(t);let r=s.ok;if(r){r=h(yield s.clone().arrayBuffer())!==i}if(r){const e=this.adapter.newRequest(this.cacheBust(t.url)),s=yield this.safeFetch(e);if(!s.ok)throw new n(`Response not Ok (cacheBustedFetchFromNetwork): cache busted request for ${t.url} returned response ${s.status} ${s.statusText}`);const r=h(yield s.clone().arrayBuffer());if(i!==r)throw new n(`Hash mismatch (cacheBustedFetchFromNetwork): ${t.url}: expected ${i}, got ${r} (after cache busting)`);return s}return s}return this.safeFetch(t)})}maybeUpdate(t,e,i){return p(this,void 0,void 0,function*(){const s=this.getConfigUrl(e.url),n=yield this.metadata;if(this.hashes.has(s)){const r=this.hashes.get(s),a=yield t.lookupResourceWithHash(s,r);if(null!==a)return yield i.put(e,a),yield n.write(e.url,{ts:this.adapter.time,used:!1}),!0}return!1})}cacheBust(t){return t+(-1===t.indexOf("?")?"?":"&")+"ngsw-cache-bust="+Math.random()}safeFetch(t){return p(this,void 0,void 0,function*(){try{return yield this.scope.fetch(t)}catch(t){return this.adapter.newResponse("",{status:504,statusText:"Gateway Timeout"})}})}}class g extends v{initializeFully(t){return p(this,void 0,void 0,function*(){const e=yield this.cache;if(yield this.config.urls.reduce((i,s)=>p(this,void 0,void 0,function*(){yield i;const n=this.adapter.newRequest(s);void 0!==(yield e.match(n))||void 0!==t&&(yield this.maybeUpdate(t,n,e))||(yield this.fetchAndCacheOnce(n,!1))}),Promise.resolve()),void 0!==t){const i=yield this.metadata;yield(yield t.previouslyCachedResources()).filter(t=>this.config.urls.some(e=>e===t)||this.patterns.some(e=>e.test(t))).reduce((s,n)=>p(this,void 0,void 0,function*(){yield s;const r=this.adapter.newRequest(n);if(void 0!==(yield e.match(r)))return;const a=yield t.lookupResourceWithoutHash(n);null!==a&&void 0!==a.metadata&&(yield e.put(r,a.response),yield i.write(n,Object.assign({},a.metadata,{used:!1})))}),Promise.resolve())}})}}class y extends v{initializeFully(t){return p(this,void 0,void 0,function*(){if(void 0===t)return;const e=yield this.cache;yield this.config.urls.reduce((s,n)=>p(this,void 0,void 0,function*(){yield s;const r=this.adapter.newRequest(n);if(void 0!==(yield e.match(r)))return;const a=yield this.maybeUpdate(t,r,e);if("prefetch"===this.config.updateMode&&!a){if((yield t.recentCacheStatus(n))!==i.CACHED)return;yield this.fetchAndCacheOnce(r,!1)}}),Promise.resolve())})}}
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */var m=function(t,e,i,s){return new(i||(i=Promise))(function(n,r){function a(t){try{o(s.next(t))}catch(t){r(t)}}function h(t){try{o(s.throw(t))}catch(t){r(t)}}function o(t){t.done?n(t.value):new i(function(e){e(t.value)}).then(a,h)}o((s=s.apply(t,e||[])).next())})};class w{constructor(t){void 0===t&&(t={head:null,tail:null,map:{},count:0}),this.state=t}get size(){return this.state.count}pop(){if(null===this.state.tail)return null;const t=this.state.tail;return this.remove(t),t}remove(t){const e=this.state.map[t];if(void 0===e)return!1;if(this.state.head===t){if(null===e.next)return this.state.head=null,this.state.tail=null,this.state.map={},this.state.count=0,!0;const i=this.state.map[e.next];return i.previous=null,this.state.head=i.url,e.next=null,delete this.state.map[t],this.state.count--,!0}return this.state.map[e.previous].next=e.next,null!==e.next?this.state.map[e.next].previous=e.previous:this.state.tail=e.previous,e.next=null,e.previous=null,delete this.state.map[t],this.state.count--,!0}accessed(t){if(this.state.head===t)return;const e=this.state.map[t]||{url:t,next:null,previous:null};void 0!==this.state.map[t]&&this.remove(t),null!==this.state.head&&(this.state.map[this.state.head].previous=t),e.next=this.state.head,this.state.head=t,null===this.state.tail&&(this.state.tail=t),this.state.map[t]=e,this.state.count++}}class C{constructor(t,e,i,s,n){this.scope=t,this.adapter=e,this.config=i,this.db=s,this.prefix=n,this._lru=null,this.patterns=this.config.patterns.map(t=>new RegExp(t)),this.cache=this.scope.caches.open(`${this.prefix}:dynamic:${this.config.name}:cache`),this.lruTable=this.db.open(`${this.prefix}:dynamic:${this.config.name}:lru`),this.ageTable=this.db.open(`${this.prefix}:dynamic:${this.config.name}:age`)}lru(){return m(this,void 0,void 0,function*(){if(null===this._lru){const t=yield this.lruTable;try{this._lru=new w(yield t.read("lru"))}catch(t){this._lru=new w}}return this._lru})}syncLru(){return m(this,void 0,void 0,function*(){if(null===this._lru)return;return(yield this.lruTable).write("lru",this._lru.state)})}handleFetch(t,e){return m(this,void 0,void 0,function*(){if(!this.patterns.some(e=>e.test(t.url)))return null;const i=yield this.lru();switch(t.method){case"OPTIONS":return null;case"GET":case"HEAD":switch(this.config.strategy){case"freshness":return this.handleFetchWithFreshness(t,e,i);case"performance":return this.handleFetchWithPerformance(t,e,i);default:throw new Error(`Unknown strategy: ${this.config.strategy}`)}default:return i.remove(t.url)&&(yield this.clearCacheForUrl(t.url)),yield this.syncLru(),this.safeFetch(t)}})}handleFetchWithPerformance(t,e,i){return m(this,void 0,void 0,function*(){let s=null;const n=yield this.loadFromCache(t,i);if(null!==n&&(s=n.res,void 0!==this.config.refreshAheadMs&&n.age>=this.config.refreshAheadMs&&e.waitUntil(this.safeCacheResponse(t,this.safeFetch(t)))),null!==s)return s;const[r,a]=this.networkFetchWithTimeout(t);return void 0===(s=yield r)&&(s=this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"}),e.waitUntil(this.safeCacheResponse(t,a))),yield this.cacheResponse(t,s,i),s})}handleFetchWithFreshness(t,e,i){return m(this,void 0,void 0,function*(){const[s,n]=this.networkFetchWithTimeout(t);let r;try{r=yield s}catch(t){r=void 0}if(void 0===r){e.waitUntil(this.safeCacheResponse(t,n));const s=yield this.loadFromCache(t,i);r=null!==s?s.res:null}else yield this.cacheResponse(t,r,i,!0);return null!==r?r:(r=yield n,yield this.cacheResponse(t,r,i,!0),r)})}networkFetchWithTimeout(t){if(void 0!==this.config.timeoutMs){const e=this.scope.fetch(t),i=(()=>m(this,void 0,void 0,function*(){try{return yield e}catch(t){return this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"})}}))(),s=(()=>m(this,void 0,void 0,function*(){try{return yield e}catch(t){return}}))(),n=this.adapter.timeout(this.config.timeoutMs);return[Promise.race([s,n]),i]}{const e=this.safeFetch(t);return[e,e]}}safeCacheResponse(t,e){return m(this,void 0,void 0,function*(){try{yield this.cacheResponse(t,yield e,yield this.lru())}catch(t){}})}loadFromCache(t,e){return m(this,void 0,void 0,function*(){const i=yield this.cache;let s=yield i.match(t);if(void 0!==s){try{const i=yield this.ageTable,n=this.adapter.time-(yield i.read(t.url)).age;if(n<=this.config.maxAge)return e.accessed(t.url),{res:s,age:n}}catch(t){}e.remove(t.url),yield this.clearCacheForUrl(t.url),yield this.syncLru()}return null})}cacheResponse(t,e,i,s=!1){return m(this,void 0,void 0,function*(){if(!e.ok||s&&"opaque"===e.type)return;if(i.size>=this.config.maxSize){const t=i.pop();null!==t&&(yield this.clearCacheForUrl(t))}i.accessed(t.url),yield(yield this.cache).put(t,e.clone());const n=yield this.ageTable;yield n.write(t.url,{age:this.adapter.time}),yield this.syncLru()})}cleanup(){return m(this,void 0,void 0,function*(){yield Promise.all([this.scope.caches.delete(`${this.prefix}:dynamic:${this.config.name}:cache`),this.db.delete(`${this.prefix}:dynamic:${this.config.name}:age`),this.db.delete(`${this.prefix}:dynamic:${this.config.name}:lru`)])})}clearCacheForUrl(t){return m(this,void 0,void 0,function*(){const[e,i]=yield Promise.all([this.cache,this.ageTable]);yield Promise.all([e.delete(this.adapter.newRequest(t,{method:"GET"})),e.delete(this.adapter.newRequest(t,{method:"HEAD"})),i.delete(t)])})}safeFetch(t){return m(this,void 0,void 0,function*(){try{return this.scope.fetch(t)}catch(t){return this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"})}})}}
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */var b=function(t,e,i,s){return new(i||(i=Promise))(function(n,r){function a(t){try{o(s.next(t))}catch(t){r(t)}}function h(t){try{o(s.throw(t))}catch(t){r(t)}}function o(t){t.done?n(t.value):new i(function(e){e(t.value)}).then(a,h)}o((s=s.apply(t,e||[])).next())})};const $=[{positive:!0,regex:"^/.*$"},{positive:!1,regex:"^/.*\\.[^/]*$"},{positive:!1,regex:"^/.*__"}];class k{constructor(t,e,i,s,n,r){this.scope=t,this.adapter=e,this.database=i,this.idle=s,this.manifest=n,this.manifestHash=r,this.hashTable=new Map,this._okay=!0,Object.keys(this.manifest.hashTable).forEach(t=>{this.hashTable.set(t,this.manifest.hashTable[t])}),this.assetGroups=(n.assetGroups||[]).map(t=>{const e=`ngsw:${this.manifestHash}:assets`;switch(t.installMode){case"prefetch":return new g(this.scope,this.adapter,this.idle,t,this.hashTable,this.database,e);case"lazy":return new y(this.scope,this.adapter,this.idle,t,this.hashTable,this.database,e)}}),this.dataGroups=(n.dataGroups||[]).map(t=>new C(this.scope,this.adapter,t,this.database,`ngsw:${t.version}:data`)),n.navigationUrls=n.navigationUrls||$;const a=n.navigationUrls.filter(t=>t.positive),h=n.navigationUrls.filter(t=>!t.positive);this.navigationUrls={include:a.map(t=>new RegExp(t.regex)),exclude:h.map(t=>new RegExp(t.regex))}}get okay(){return this._okay}initializeFully(t){return b(this,void 0,void 0,function*(){try{yield this.assetGroups.reduce((e,i)=>b(this,void 0,void 0,function*(){return yield e,i.initializeFully(t)}),Promise.resolve())}catch(t){throw this._okay=!1,t}})}handleFetch(t,e){return b(this,void 0,void 0,function*(){const i=yield this.assetGroups.reduce((i,s)=>b(this,void 0,void 0,function*(){const n=yield i;return null!==n?n:s.handleFetch(t,e)}),Promise.resolve(null));if(null!==i)return i;const s=yield this.dataGroups.reduce((i,s)=>b(this,void 0,void 0,function*(){const n=yield i;return null!==n?n:s.handleFetch(t,e)}),Promise.resolve(null));return null!==s?s:t.url!==this.manifest.index&&this.isNavigationRequest(t)?this.handleFetch(this.adapter.newRequest(this.manifest.index),e):null})}isNavigationRequest(t){if("navigate"!==t.mode)return!1;if(!this.acceptsTextHtml(t))return!1;const e=this.scope.registration.scope.replace(/\/$/,""),i=(t.url.startsWith(e)?t.url.substr(e.length):t.url).replace(/[?#].*$/,"");return this.navigationUrls.include.some(t=>t.test(i))&&!this.navigationUrls.exclude.some(t=>t.test(i))}lookupResourceWithHash(t,e){return b(this,void 0,void 0,function*(){if(!this.hashTable.has(t))return null;if(this.hashTable.get(t)!==e)return null;const i=yield this.lookupResourceWithoutHash(t);return i&&i.response})}lookupResourceWithoutHash(t){return this.assetGroups.reduce((e,i)=>b(this,void 0,void 0,function*(){const s=yield e;return null!==s?s:i.fetchFromCacheOnly(t)}),Promise.resolve(null))}previouslyCachedResources(){return this.assetGroups.reduce((t,e)=>b(this,void 0,void 0,function*(){return(yield t).concat(yield e.unhashedResources())}),Promise.resolve([]))}recentCacheStatus(t){return b(this,void 0,void 0,function*(){return this.assetGroups.reduce((e,s)=>b(this,void 0,void 0,function*(){const n=yield e;if(n===i.CACHED)return n;const r=yield s.cacheStatus(t);return r===i.NOT_CACHED?n:r}),Promise.resolve(i.NOT_CACHED))})}cleanup(){return b(this,void 0,void 0,function*(){yield Promise.all(this.assetGroups.map(t=>t.cleanup())),yield Promise.all(this.dataGroups.map(t=>t.cleanup()))})}get appData(){return this.manifest.appData||null}acceptsTextHtml(t){const e=t.headers.get("Accept");return null!==e&&e.split(",").some(t=>"text/html"===t.trim().toLowerCase())}}
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */var R=function(t,e,i,s){return new(i||(i=Promise))(function(n,r){function a(t){try{o(s.next(t))}catch(t){r(t)}}function h(t){try{o(s.throw(t))}catch(t){r(t)}}function o(t){t.done?n(t.value):new i(function(e){e(t.value)}).then(a,h)}o((s=s.apply(t,e||[])).next())})};const A=100;class E{constructor(t,e){this.driver=t,this.adapter=e,this.debugLogA=[],this.debugLogB=[]}handleFetch(t){return R(this,void 0,void 0,function*(){const[t,e,i]=yield Promise.all([this.driver.debugState(),this.driver.debugVersions(),this.driver.debugIdleState()]),s=`NGSW Debug Info:\n\nDriver state: ${t.state} (${t.why})\nLatest manifest hash: ${t.latestHash||"none"}\nLast update check: ${this.since(t.lastUpdateCheck)}`,n=e.map(t=>`=== Version ${t.hash} ===\n\nClients: ${t.clients.join(", ")}`).join("\n\n"),r=`=== Idle Task Queue ===\nLast update tick: ${this.since(i.lastTrigger)}\nLast update run: ${this.since(i.lastRun)}\nTask queue:\n${i.queue.map(t=>" * "+t).join("\n")}\n\nDebug log:\n${this.formatDebugLog(this.debugLogB)}\n${this.formatDebugLog(this.debugLogA)}\n`;return this.adapter.newResponse(`${s}\n\n${n}\n\n${r}`,{headers:this.adapter.newHeaders({"Content-Type":"text/plain"})})})}since(t){if(null===t)return"never";let e=this.adapter.time-t;const i=Math.floor(e/864e5);e%=864e5;const s=Math.floor(e/36e5);e%=36e5;const n=Math.floor(e/6e4);e%=6e4;const r=Math.floor(e/1e3),a=e%1e3;return""+(i>0?`${i}d`:"")+(s>0?`${s}h`:"")+(n>0?`${n}m`:"")+(r>0?`${r}s`:"")+(a>0?`${a}u`:"")}log(t,e=""){this.debugLogA.length===A&&(this.debugLogB=this.debugLogA,this.debugLogA=[]),"string"!=typeof t&&(t=this.errorToString(t)),this.debugLogA.push({value:t,time:this.adapter.time,context:e})}errorToString(t){return`${t.name}(${t.message}, ${t.stack})`}formatDebugLog(t){return t.map(t=>`[${this.since(t.time)}] ${t.value} ${t.context}`).join("\n")}}
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */var F=function(t,e,i,s){return new(i||(i=Promise))(function(n,r){function a(t){try{o(s.next(t))}catch(t){r(t)}}function h(t){try{o(s.throw(t))}catch(t){r(t)}}function o(t){t.done?n(t.value):new i(function(e){e(t.value)}).then(a,h)}o((s=s.apply(t,e||[])).next())})};class H{constructor(t,e,i){this.adapter=t,this.threshold=e,this.debug=i,this.queue=[],this.scheduled=null,this.empty=Promise.resolve(),this.emptyResolve=null,this.lastTrigger=null,this.lastRun=null}trigger(){return F(this,void 0,void 0,function*(){if(this.lastTrigger=this.adapter.time,0===this.queue.length)return;null!==this.scheduled&&(this.scheduled.cancel=!0);const t={cancel:!1};this.scheduled=t,yield this.adapter.timeout(this.threshold),t.cancel||(this.scheduled=null,yield this.execute())})}execute(){return F(this,void 0,void 0,function*(){for(this.lastRun=this.adapter.time;this.queue.length>0;){const t=this.queue;this.queue=[],yield t.reduce((t,e)=>F(this,void 0,void 0,function*(){yield t;try{yield e.run()}catch(t){this.debug.log(t,`while running idle task ${e.desc}`)}}),Promise.resolve())}null!==this.emptyResolve&&(this.emptyResolve(),this.emptyResolve=null),this.empty=Promise.resolve()})}schedule(t,e){this.queue.push({desc:t,run:e}),null===this.emptyResolve&&(this.empty=new Promise(t=>{this.emptyResolve=t}))}get size(){return this.queue.length}get taskDescriptions(){return this.queue.map(t=>t.desc)}}
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */function x(t){return a(JSON.stringify(t))}
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
var T=function(t,e,i,s){return new(i||(i=Promise))(function(n,r){function a(t){try{o(s.next(t))}catch(t){r(t)}}function h(t){try{o(s.throw(t))}catch(t){r(t)}}function o(t){t.done?n(t.value):new i(function(e){e(t.value)}).then(a,h)}o((s=s.apply(t,e||[])).next())})};const U=5e3,M=1,q=["actions","badge","body","data","dir","icon","image","lang","renotify","requireInteraction","silent","tag","timestamp","title","vibrate"];var L;!function(t){t[t.NORMAL=0]="NORMAL",t[t.EXISTING_CLIENTS_ONLY=1]="EXISTING_CLIENTS_ONLY",t[t.SAFE_MODE=2]="SAFE_MODE"}(L||(L={}));
/**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
const D=self,O=new class{newRequest(t,e){return new Request(t,e)}newResponse(t,e){return new Response(t,e)}newHeaders(t){return new Headers(t)}isClient(t){return t instanceof Client}get time(){return Date.now()}parseUrl(t,e){const i=new URL(t,e);return{origin:i.origin,path:i.pathname}}timeout(t){return new Promise(e=>{setTimeout(()=>e(),t)})}};new class{constructor(t,e,i){this.scope=t,this.adapter=e,this.db=i,this.state=L.NORMAL,this.stateMessage="(nominal)",this.initialized=null,this.clientVersionMap=new Map,this.versions=new Map,this.latestHash=null,this.lastUpdateCheck=null,this.scheduledNavUpdateCheck=!1,this.loggedInvalidOnlyIfCachedRequest=!1,this.scope.addEventListener("install",t=>{t.waitUntil(this.scope.skipWaiting())}),this.scope.addEventListener("activate",t=>{t.waitUntil((()=>T(this,void 0,void 0,function*(){yield this.scope.clients.claim(),this.idle.schedule("activate: cleanup-old-sw-caches",()=>T(this,void 0,void 0,function*(){try{yield this.cleanupOldSwCaches()}catch(t){this.debugger.log(t,"cleanupOldSwCaches @ activate: cleanup-old-sw-caches")}}))}))()),null!==this.scope.registration.active&&this.scope.registration.active.postMessage({action:"INITIALIZE"})}),this.scope.addEventListener("fetch",t=>this.onFetch(t)),this.scope.addEventListener("message",t=>this.onMessage(t)),this.scope.addEventListener("push",t=>this.onPush(t)),this.scope.addEventListener("notificationclick",t=>this.onClick(t)),this.debugger=new E(this,this.adapter),this.idle=new H(this.adapter,U,this.debugger)}onFetch(t){const e=t.request,i=this.scope.registration.scope,s=this.adapter.parseUrl(e.url,i);"/ngsw/state"!==s.path?this.state!==L.SAFE_MODE?s.origin.startsWith("http:")&&i.startsWith("https:")?this.debugger.log(`Ignoring passive mixed content request: Driver.fetch(${e.url})`):"only-if-cached"!==e.cache||"same-origin"===e.mode?t.respondWith(this.handleFetch(t)):this.loggedInvalidOnlyIfCachedRequest||(this.loggedInvalidOnlyIfCachedRequest=!0,this.debugger.log("Ignoring invalid request: 'only-if-cached' can be set only with 'same-origin' mode",`Driver.fetch(${e.url}, cache: ${e.cache}, mode: ${e.mode})`)):t.waitUntil(this.idle.trigger()):t.respondWith(this.debugger.handleFetch(e))}onMessage(t){if(this.state===L.SAFE_MODE)return;const e=t.data;e&&e.action&&("INITIALIZE"!==e.action?this.adapter.isClient(t.source)&&t.waitUntil(this.handleMessage(e,t.source)):null===this.initialized&&(this.initialized=this.initialize(),t.waitUntil((()=>T(this,void 0,void 0,function*(){yield this.initialized,yield this.idle.trigger()}))())))}onPush(t){t.data&&t.waitUntil(this.handlePush(t.data.json()))}onClick(t){t.waitUntil(this.handleClick(t.notification,t.action))}handleMessage(t,e){return T(this,void 0,void 0,function*(){if(function(t){return"CHECK_FOR_UPDATES"===t.action}(t)){const i=(()=>T(this,void 0,void 0,function*(){yield this.checkForUpdate()}))();yield this.reportStatus(e,i,t.statusNonce)}else(function(t){return"ACTIVATE_UPDATE"===t.action})(t)&&(yield this.reportStatus(e,this.updateClient(e),t.statusNonce))})}handlePush(t){return T(this,void 0,void 0,function*(){if(yield this.broadcast({type:"PUSH",data:t}),!t.notification||!t.notification.title)return;const e=t.notification;let i={};q.filter(t=>e.hasOwnProperty(t)).forEach(t=>i[t]=e[t]),yield this.scope.registration.showNotification(e.title,i)})}handleClick(t,e){return T(this,void 0,void 0,function*(){t.close();const i={};q.filter(e=>e in t).forEach(e=>i[e]=t[e]),yield this.broadcast({type:"NOTIFICATION_CLICK",data:{action:e,notification:i}})})}reportStatus(t,e,i){return T(this,void 0,void 0,function*(){const s={type:"STATUS",nonce:i,status:!0};try{yield e,t.postMessage(s)}catch(e){t.postMessage(Object.assign({},s,{status:!1,error:e.toString()}))}})}updateClient(t){return T(this,void 0,void 0,function*(){const e=this.clientVersionMap.get(t.id);if(e===this.latestHash)return;let i=void 0;if(void 0!==e){const t=this.versions.get(e);i=this.mergeHashWithAppData(t.manifest,e)}this.clientVersionMap.set(t.id,this.latestHash),yield this.sync();const s=this.versions.get(this.latestHash),n={type:"UPDATE_ACTIVATED",previous:i,current:this.mergeHashWithAppData(s.manifest,this.latestHash)};t.postMessage(n)})}handleFetch(t){return T(this,void 0,void 0,function*(){null===this.initialized&&(this.initialized=this.initialize());try{yield this.initialized}catch(e){return this.state=L.SAFE_MODE,this.stateMessage=`Initialization failed due to error: ${r(e)}`,t.waitUntil(this.idle.trigger()),this.safeFetch(t.request)}"navigate"!==t.request.mode||this.scheduledNavUpdateCheck||(this.scheduledNavUpdateCheck=!0,this.idle.schedule("check-updates-on-navigation",()=>T(this,void 0,void 0,function*(){this.scheduledNavUpdateCheck=!1,yield this.checkForUpdate()})));const e=yield this.assignVersion(t);if(null===e)return t.waitUntil(this.idle.trigger()),this.safeFetch(t.request);let i=null;try{i=yield e.handleFetch(t.request,t)}catch(i){if(i.isCritical)return yield this.versionFailed(e,i,this.latestHash===e.manifestHash),t.waitUntil(this.idle.trigger()),this.safeFetch(t.request);throw i}return null===i?(t.waitUntil(this.idle.trigger()),this.safeFetch(t.request)):(t.waitUntil(this.idle.trigger()),i)})}initialize(){return T(this,void 0,void 0,function*(){const t=yield this.db.open("control");let e,i,s;try{[e,i,s]=yield Promise.all([t.read("manifests"),t.read("assignments"),t.read("latest")]),this.idle.schedule("init post-load (update, cleanup)",()=>T(this,void 0,void 0,function*(){yield this.checkForUpdate();try{yield this.cleanupCaches()}catch(t){this.debugger.log(t,"cleanupCaches @ init post-load")}}))}catch(n){const r=yield this.fetchLatestManifest(),a=x(r);(e={})[a]=r,i={},s={latest:a},yield Promise.all([t.write("manifests",e),t.write("assignments",i),t.write("latest",s)])}if(Object.keys(e).forEach(t=>{const i=e[t];this.versions.has(t)||this.versions.set(t,new k(this.scope,this.adapter,this.db,this.idle,i,t))}),Object.keys(i).forEach(t=>{const e=i[t];this.versions.has(e)?this.clientVersionMap.set(t,e):(this.clientVersionMap.set(t,s.latest),this.debugger.log(`Unknown version ${e} mapped for client ${t}, using latest instead`,"initialize: map assignments"))}),this.latestHash=s.latest,!this.versions.has(s.latest))throw new Error(`Invariant violated (initialize): latest hash ${s.latest} has no known manifest`);yield Promise.all(Object.keys(e).map(t=>T(this,void 0,void 0,function*(){try{yield this.scheduleInitialization(this.versions.get(t),this.latestHash===t)}catch(e){return this.debugger.log(e,`initialize: schedule init of ${t}`),!1}})))})}lookupVersionByHash(t,e="lookupVersionByHash"){if(!this.versions.has(t))throw new Error(`Invariant violated (${e}): want AppVersion for ${t} but not loaded`);return this.versions.get(t)}assignVersion(t){return T(this,void 0,void 0,function*(){const e=t.clientId;if(e){if(this.clientVersionMap.has(e)){const i=this.clientVersionMap.get(e);let s=this.lookupVersionByHash(i,"assignVersion");if(this.state===L.NORMAL&&i!==this.latestHash&&s.isNavigationRequest(t.request)){if(null===this.latestHash)throw new Error("Invariant violated (assignVersion): latestHash was null");const t=yield this.scope.clients.get(e);yield this.updateClient(t),s=this.lookupVersionByHash(this.latestHash,"assignVersion")}return s}if(this.state!==L.NORMAL)return null;if(null===this.latestHash)throw new Error("Invariant violated (assignVersion): latestHash was null");return this.clientVersionMap.set(e,this.latestHash),yield this.sync(),this.lookupVersionByHash(this.latestHash,"assignVersion")}if(this.state!==L.NORMAL)return null;if(null===this.latestHash)throw new Error("Invariant violated (assignVersion): latestHash was null");return this.lookupVersionByHash(this.latestHash,"assignVersion")})}fetchLatestManifest(t=!1){return T(this,void 0,void 0,function*(){const e=yield this.safeFetch(this.adapter.newRequest("ngsw.json?ngsw-cache-bust="+Math.random()));if(!e.ok){if(404===e.status)yield this.deleteAllCaches(),yield this.scope.registration.unregister();else if(504===e.status&&t)return null;throw new Error(`Manifest fetch failed! (status: ${e.status})`)}return this.lastUpdateCheck=this.adapter.time,e.json()})}deleteAllCaches(){return T(this,void 0,void 0,function*(){yield(yield this.scope.caches.keys()).filter(t=>t.startsWith("ngsw:")).reduce((t,e)=>T(this,void 0,void 0,function*(){yield Promise.all([t,this.scope.caches.delete(e)])}),Promise.resolve())})}scheduleInitialization(t,e){return T(this,void 0,void 0,function*(){const i=()=>T(this,void 0,void 0,function*(){try{yield t.initializeFully()}catch(i){this.debugger.log(i,`initializeFully for ${t.manifestHash}`),yield this.versionFailed(t,i,e)}});if(this.scope.registration.scope.indexOf("://localhost")>-1)return i();this.idle.schedule(`initialization(${t.manifestHash})`,i)})}versionFailed(t,e,i){return T(this,void 0,void 0,function*(){const s=Array.from(this.versions.entries()).find(([e,i])=>i===t);if(void 0===s)return;const n=s[0];this.latestHash===n||i?(this.state=L.EXISTING_CLIENTS_ONLY,this.stateMessage=`Degraded due to: ${r(e)}`,Array.from(this.clientVersionMap.keys()).forEach(t=>this.clientVersionMap.delete(t))):Array.from(this.clientVersionMap.keys()).filter(t=>this.clientVersionMap.get(t)===n).forEach(t=>this.clientVersionMap.set(t,this.latestHash));try{yield this.sync()}catch(t){this.debugger.log(t,`Driver.versionFailed(${e.message||e})`)}})}setupUpdate(t,e){return T(this,void 0,void 0,function*(){const i=new k(this.scope,this.adapter,this.db,this.idle,t,e);if(t.configVersion!==M)throw yield this.deleteAllCaches(),yield this.scope.registration.unregister(),new Error(`Invalid config version: expected ${M}, got ${t.configVersion}.`);yield i.initializeFully(this),this.versions.set(e,i),this.latestHash=e,yield this.sync(),yield this.notifyClientsAboutUpdate()})}checkForUpdate(){return T(this,void 0,void 0,function*(){let t="(unknown)";try{const e=yield this.fetchLatestManifest(!0);return null===e?(this.debugger.log("Check for update aborted. (Client or server offline.)"),!1):(t=x(e),!this.versions.has(t)&&(yield this.setupUpdate(e,t),!0))}catch(e){return this.debugger.log(e,`Error occurred while updating to manifest ${t}`),this.state=L.EXISTING_CLIENTS_ONLY,this.stateMessage=`Degraded due to failed initialization: ${r(e)}`,!1}})}sync(){return T(this,void 0,void 0,function*(){const t=yield this.db.open("control"),e={};this.versions.forEach((t,i)=>{e[i]=t.manifest});const i={};this.clientVersionMap.forEach((t,e)=>{i[e]=t});const s={latest:this.latestHash};yield Promise.all([t.write("manifests",e),t.write("assignments",i),t.write("latest",s)])})}cleanupCaches(){return T(this,void 0,void 0,function*(){const t=(yield this.scope.clients.matchAll()).map(t=>t.id);Array.from(this.clientVersionMap.keys()).filter(e=>-1===t.indexOf(e)).forEach(t=>this.clientVersionMap.delete(t));const e=new Set;this.clientVersionMap.forEach((t,i)=>e.add(t));const i=Array.from(this.versions.keys()).filter(t=>!e.has(t)&&t!==this.latestHash);yield i.reduce((t,e)=>T(this,void 0,void 0,function*(){yield t;try{const t=this.versions.get(e);this.versions.delete(e),yield t.cleanup()}catch(t){this.debugger.log(t,`cleanupCaches - cleanup ${e}`)}}),Promise.resolve()),yield this.sync()})}cleanupOldSwCaches(){return T(this,void 0,void 0,function*(){const t=(yield this.scope.caches.keys()).filter(t=>/^ngsw:(?:active|staged|manifest:.+)$/.test(t));yield Promise.all(t.map(t=>this.scope.caches.delete(t)))})}lookupResourceWithHash(t,e){return Array.from(this.versions.values()).reduce((i,s)=>T(this,void 0,void 0,function*(){return null!==(yield i)?i:s.lookupResourceWithHash(t,e)}),Promise.resolve(null))}lookupResourceWithoutHash(t){return T(this,void 0,void 0,function*(){return yield this.initialized,this.versions.get(this.latestHash).lookupResourceWithoutHash(t)})}previouslyCachedResources(){return T(this,void 0,void 0,function*(){return yield this.initialized,this.versions.get(this.latestHash).previouslyCachedResources()})}recentCacheStatus(t){return this.versions.get(this.latestHash).recentCacheStatus(t)}mergeHashWithAppData(t,e){return{hash:e,appData:t.appData}}notifyClientsAboutUpdate(){return T(this,void 0,void 0,function*(){yield this.initialized;const t=yield this.scope.clients.matchAll(),e=this.versions.get(this.latestHash);yield t.reduce((t,i)=>T(this,void 0,void 0,function*(){yield t;const s=this.clientVersionMap.get(i.id);if(void 0===s)return;if(s===this.latestHash)return;const n=this.versions.get(s),r={type:"UPDATE_AVAILABLE",current:this.mergeHashWithAppData(n.manifest,s),available:this.mergeHashWithAppData(e.manifest,this.latestHash)};i.postMessage(r)}),Promise.resolve())})}broadcast(t){return T(this,void 0,void 0,function*(){(yield this.scope.clients.matchAll()).forEach(e=>{e.postMessage(t)})})}debugState(){return T(this,void 0,void 0,function*(){return{state:L[this.state],why:this.stateMessage,latestHash:this.latestHash,lastUpdateCheck:this.lastUpdateCheck}})}debugVersions(){return T(this,void 0,void 0,function*(){return Array.from(this.versions.keys()).map(t=>{const e=this.versions.get(t),i=Array.from(this.clientVersionMap.entries()).filter(([e,i])=>i===t).map(([t,e])=>t);return{hash:t,manifest:e.manifest,clients:i,status:""}})})}debugIdleState(){return T(this,void 0,void 0,function*(){return{queue:this.idle.taskDescriptions,lastTrigger:this.idle.lastTrigger,lastRun:this.idle.lastRun}})}safeFetch(t){return T(this,void 0,void 0,function*(){try{return yield this.scope.fetch(t)}catch(e){return this.debugger.log(e,`Driver.fetch(${t.url})`),this.adapter.newResponse(null,{status:504,statusText:"Gateway Timeout"})}})}}(D,O,new class{constructor(t,e){this.scope=t,this.adapter=e,this.tables=new Map}delete(t){return this.tables.has(t)&&this.tables.delete(t),this.scope.caches.delete(`ngsw:db:${t}`)}list(){return this.scope.caches.keys().then(t=>t.filter(t=>t.startsWith("ngsw:db:")))}open(t){if(!this.tables.has(t)){const i=this.scope.caches.open(`ngsw:db:${t}`).then(i=>new e(t,i,this.adapter));this.tables.set(t,i)}return this.tables.get(t)}}(D,O))}();